{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"M\u00e1ster en Tecnolog\u00edas y Aplicaciones en Ingenier\u00eda en Inform\u00e1tica - UAL BDGE (Bases de Datos a Gran Escala) El crecimiento en la produccio\u0301n de los datos de usuario, sensores, sistemas GPS, y dema\u0301s, han disparado el taman\u0303o y el tipo de los datos generados, los cuales adema\u0301s pueden ser de naturaleza no estructurada. Estos grandes volu\u0301menes de datos suponen nuevos desafi\u0301os en te\u0301rminos de almacenamiento y procesamiento, por los que las te\u0301cnicas tradicionales de gestio\u0301n de datos no son aplicables directamente en este contexto. Bajo el te\u0301rmino de NoSQL se encuentran los pricipales productos de bases de datos para tratar con este problema, como son las bases de datos orientadas a columnas, bases de datos clave-valor y bases de datos de documentos. En esta asignatura se estudian los conceptos fundamentales relacionados con NoSQL en el contexto de diferentes productos comerciales. Contenidos El feno\u0301nomeno NoSQL Modelos de almacenamiento Escalabilidad y Replicacio\u0301n Desarrollo de aplicaciones con BD NoSQL Redis, MongoDB, Neo4j, ... Horario de clase y de tutori\u0301as Clases: Laboratorio An\u00e1lisis y Desarrollo de Software - CITE III \u2013 (1.01) Sesiones presenciales ( Planficaci\u00f3n detallada ] 11 de abril de 18h a 20h 13 de abril de 18h a 20h 18 de abril de 18h a 20h 20 de abril de 18h a 20h 26 de abril de 18h a 20h 27 de abril de 18h a 20h 10 de mayo de 16h a 18h 11 de mayo de 18h a 20h 8 sesiones presenciales = 16 horas. 7 sesiones no presenciales = 14 horas Profesor: Manuel Torres Gil Tutori\u0301as: Martes y Jueves de 11h a 14h Despacho: 2.19.5 CITE III (2a planta) email: mtorres@ual.es Twitter: @ualmtorres Co\u0301mo seguir la asignatura Material disponible en Aula Virtual Repositorio Git (accesible so\u0301lo mediante VPN UAL) Clases participativas Contenido pra\u0301ctico Planteamiento de retos/desafi\u0301os Redis MongoDB Neo4j Gu\u00eda de estudio Co\u0301mo superar la asignatura Las competencias de la asignatura se evalu\u0301an mediante la aplicacion de los conocimientos teoricos de la asignatura en la solucion de los diferentes problemas planteados en las sesiones de grupos de trabajo. En concreto, para superar la asignatura, es condicion necesaria que el alumno: * Complete con exito y a tiempo todas las practicas desarrolladas en el Grupo de Trabajo. * Desarrolle todas las actividades de Trabajo auto\u0301nomo * Se valora la asistencia y participacio\u0301n * Planteamiento de retos/desafi\u0301os * Redis * MongoDB * Neo4j En la Gu\u00eda docente de la asignatura se pueden encontrar la informaci\u00f3n detallada sobre la evaluaci\u00f3n de la asignatura. Desarrollo de la Gu\u00eda docente A continuaci\u00f3n se muestra en qu\u00e9 sesi\u00f3n se desarrollar\u00e1n cada uno de los contenidos que aparecen en la Gu\u00eda docente de la asignatura. Bases de datos no relacionales El feno\u0301nomeno NoSQL Modelos de almacenamiento NoSQL Consultas sobre grandes vol\u00famenes de datos Consultas en bases de datos clave-valor Bases de datos clave-valor (Redis) Interacci\u00f3n con Redis desde Java Interacci\u00f3n con Redis desde PHP Consultas en bases de datos orientadas a documentos Bases de datos orientadas a documentos (MongoDB) MongoDB - Indexaci\u00f3n Interacci\u00f3n con MongoDB usando PHP Interacci\u00f3n con MongoDB usando Java MongoDB \u2013 Framework de Agregaci\u00f3n Consultas en bases de datos orientadas a grafos Bases de datos orientadas a Grafos (Neo4j) Neo4j desde aplicaciones PHP Consultas en bases de datos orientadas a columnas Bases de datos orientadas a columnas (Cassandra) Escalabilidad de bases de datos Replicaci\u00f3n y sharding MongoDB - Sharding MongoDB - Replicaci\u00f3n Desarrollo de aplicaciones para grandes vol\u00famenes de datos Desarrollo de aplicaciones sobre bases de datos NoSQL Configuraci\u00f3n del entorno de la asignatura Interacci\u00f3n con Redis desde Java Interacci\u00f3n con Redis desde PHP Interacci\u00f3n con MongoDB usando PHP Interacci\u00f3n con MongoDB usando Java Object Data Mappers (ODM) Neo4j desde aplicaciones PHP Material complementario Tutorial de Node.js Interacci\u00f3n con Redis usando Node.js","title":"Inicio"},{"location":"#master-en-tecnologias-y-aplicaciones-en-ingenieria-en-informatica-ual","text":"","title":"M\u00e1ster en Tecnolog\u00edas y Aplicaciones en Ingenier\u00eda en Inform\u00e1tica - UAL"},{"location":"#bdge-bases-de-datos-a-gran-escala","text":"El crecimiento en la produccio\u0301n de los datos de usuario, sensores, sistemas GPS, y dema\u0301s, han disparado el taman\u0303o y el tipo de los datos generados, los cuales adema\u0301s pueden ser de naturaleza no estructurada. Estos grandes volu\u0301menes de datos suponen nuevos desafi\u0301os en te\u0301rminos de almacenamiento y procesamiento, por los que las te\u0301cnicas tradicionales de gestio\u0301n de datos no son aplicables directamente en este contexto. Bajo el te\u0301rmino de NoSQL se encuentran los pricipales productos de bases de datos para tratar con este problema, como son las bases de datos orientadas a columnas, bases de datos clave-valor y bases de datos de documentos. En esta asignatura se estudian los conceptos fundamentales relacionados con NoSQL en el contexto de diferentes productos comerciales.","title":"BDGE (Bases de Datos a Gran Escala)"},{"location":"#contenidos","text":"El feno\u0301nomeno NoSQL Modelos de almacenamiento Escalabilidad y Replicacio\u0301n Desarrollo de aplicaciones con BD NoSQL Redis, MongoDB, Neo4j, ...","title":"Contenidos"},{"location":"#horario-de-clase-y-de-tutorias","text":"Clases: Laboratorio An\u00e1lisis y Desarrollo de Software - CITE III \u2013 (1.01) Sesiones presenciales ( Planficaci\u00f3n detallada ] 11 de abril de 18h a 20h 13 de abril de 18h a 20h 18 de abril de 18h a 20h 20 de abril de 18h a 20h 26 de abril de 18h a 20h 27 de abril de 18h a 20h 10 de mayo de 16h a 18h 11 de mayo de 18h a 20h 8 sesiones presenciales = 16 horas. 7 sesiones no presenciales = 14 horas Profesor: Manuel Torres Gil Tutori\u0301as: Martes y Jueves de 11h a 14h Despacho: 2.19.5 CITE III (2a planta) email: mtorres@ual.es Twitter: @ualmtorres","title":"Horario de clase y de tutori\u0301as"},{"location":"#como-seguir-la-asignatura","text":"Material disponible en Aula Virtual Repositorio Git (accesible so\u0301lo mediante VPN UAL) Clases participativas Contenido pra\u0301ctico Planteamiento de retos/desafi\u0301os Redis MongoDB Neo4j Gu\u00eda de estudio","title":"Co\u0301mo seguir la asignatura"},{"location":"#como-superar-la-asignatura","text":"Las competencias de la asignatura se evalu\u0301an mediante la aplicacion de los conocimientos teoricos de la asignatura en la solucion de los diferentes problemas planteados en las sesiones de grupos de trabajo. En concreto, para superar la asignatura, es condicion necesaria que el alumno: * Complete con exito y a tiempo todas las practicas desarrolladas en el Grupo de Trabajo. * Desarrolle todas las actividades de Trabajo auto\u0301nomo * Se valora la asistencia y participacio\u0301n * Planteamiento de retos/desafi\u0301os * Redis * MongoDB * Neo4j En la Gu\u00eda docente de la asignatura se pueden encontrar la informaci\u00f3n detallada sobre la evaluaci\u00f3n de la asignatura.","title":"Co\u0301mo superar la asignatura"},{"location":"#desarrollo-de-la-guia-docente","text":"A continuaci\u00f3n se muestra en qu\u00e9 sesi\u00f3n se desarrollar\u00e1n cada uno de los contenidos que aparecen en la Gu\u00eda docente de la asignatura. Bases de datos no relacionales El feno\u0301nomeno NoSQL Modelos de almacenamiento NoSQL Consultas sobre grandes vol\u00famenes de datos Consultas en bases de datos clave-valor Bases de datos clave-valor (Redis) Interacci\u00f3n con Redis desde Java Interacci\u00f3n con Redis desde PHP Consultas en bases de datos orientadas a documentos Bases de datos orientadas a documentos (MongoDB) MongoDB - Indexaci\u00f3n Interacci\u00f3n con MongoDB usando PHP Interacci\u00f3n con MongoDB usando Java MongoDB \u2013 Framework de Agregaci\u00f3n Consultas en bases de datos orientadas a grafos Bases de datos orientadas a Grafos (Neo4j) Neo4j desde aplicaciones PHP Consultas en bases de datos orientadas a columnas Bases de datos orientadas a columnas (Cassandra) Escalabilidad de bases de datos Replicaci\u00f3n y sharding MongoDB - Sharding MongoDB - Replicaci\u00f3n Desarrollo de aplicaciones para grandes vol\u00famenes de datos Desarrollo de aplicaciones sobre bases de datos NoSQL Configuraci\u00f3n del entorno de la asignatura Interacci\u00f3n con Redis desde Java Interacci\u00f3n con Redis desde PHP Interacci\u00f3n con MongoDB usando PHP Interacci\u00f3n con MongoDB usando Java Object Data Mappers (ODM) Neo4j desde aplicaciones PHP","title":"Desarrollo de la Gu\u00eda docente"},{"location":"#material-complementario","text":"Tutorial de Node.js Interacci\u00f3n con Redis usando Node.js","title":"Material complementario"},{"location":"Neo4jPHP/","text":"Usando Neo4j y PHP Duraci\u00f3n estimada: 60 minutos Neo4j nos ofrece gran cantidad de clientes para interactuar con \u00e9l mediante diferentes lenguajes de programaci\u00f3n ( Drivers Neo4j ). En nuestro ejemplo interactuaremos con Neo4j mediante PHP. Para PHP existen varios drivers (Neo4jPHP, NeoClient, ...). En la web de Neo4j puedes encontrar una lista m\u00e1s completa de clientes PHP para Neo4j . En este tutorial usaremos NeoClient . Instalaci\u00f3n Como paso previo a la instalaci\u00f3n de NeoClient, necesitas tener instalado Composer , un gestor de dependencias para PHP. En el Tutorial sobre configuraci\u00f3n de un entorno LAMP+NoSQL est\u00e1n disponibles los pasos para tener instalado todo lo necesario para usar Neo4j con PHP (Neo4j, Servidor Apache, PHP y Composer). Siguiendo la Informaci\u00f3n de instalaci\u00f3n de NeoClient hay que crear en la carpeta del proyecto un archivo composer.json en el que se especifica la dependencia con NeoClient. A continuaci\u00f3n, en la carpeta del proyecto instalaremos las dependencias con el comando siguiente composer install Conexi\u00f3n a Neo4j Para usar las clases de NeoClient debemos hacer referencia el espacio de nombres de NeoClient ( Neoxygen\\NeoClient ). Adem\u00e1s, antes de proceder a crear la conexi\u00f3n tenemos que importar el archivo autoload.php generado por Composer al instalar las dependencias. La conexi\u00f3n la crearemos mediante el m\u00e9todo create() de la clase ClientBuilder de NeoClient. En ella indicaremos varios par\u00e1metros, destacando el host y el puerto . En nuestro caso hemos usado localhost y 7474 (el puerto predeterminado de Neo4j). Este c\u00f3digo lo podemos guardar en un archivo (p.e. connection.php ) para que pueda ser utilizado por cualquier script de nuestra aplicaci\u00f3n que tenga que interactuar con Neo4j. Interacci\u00f3n con Neo4j B\u00e1sicamente, la interacci\u00f3n con Neo4j la realizaremos mediante el env\u00edo de consultas Cypher a trav\u00e9s de la conexi\u00f3n que hemos establecido en el paso anterior. El env\u00edo de estas consultas se realiza aplicando a una conexi\u00f3n el m\u00e9todo sendCypherQuery($query, [$params]) . Este m\u00e9todo toma como argumento una consulta Cypher y opcionalmente un array asociativo de par\u00e1metros. Creaci\u00f3n de nodos Los nodos son creados definiendo expresiones en Cypher que ser\u00e1n pasadas como argumento al m\u00e9todo sendCypherQuery() sobre la conexi\u00f3n creada. A continuaci\u00f3n vemos c\u00f3mo crear un nodo Person para un actor con nombre ( name ) John Doe , y un nodo Movie para una pel\u00edcula con t\u00edtulo ( title ) GGVD . Creaci\u00f3n de relaciones Al igual que los nodos, las relaciones son creadas definiendo expresiones en Cypher que ser\u00e1n pasadas como argumento al m\u00e9todo sendCypherQuery() sobre la conexi\u00f3n creada. A continuaci\u00f3n vemos c\u00f3mo crear una relaci\u00f3n entre los nodos Person y Movie creados anteriormente. La relaci\u00f3n se denomina ACTED_IN y tiene asociada la propiedad roles con el valor ['Johnnie'] indicando que el actor John Doe tiene el papel (rol) de Johnnie en la pel\u00edcula GGVD . Uso de par\u00e1metros en las consultas Las consultas Cypher que pasamos al m\u00e9todo sendCypherQuery() se pueden definir parametrizadas. Los par\u00e1metros se asignar\u00e1n posteriormente antes de enviar la consulta a Neo4j. A continuaci\u00f3n se muestra la misma consulta que usamos anteriormente para definir una relaci\u00f3n ACTED_IN entre un nodo Person y un nodo Movie , pero ahora la crearemos de forma parametrizada. En este caso, el nombre de la persona es pasado como par\u00e1metro ( {theName} ), as\u00ed como el t\u00edtulo de la pel\u00edcula ( {theTitle} ). Para asignar valores a los par\u00e1metros crearemos un array asociativo que tendr\u00e1 tantos elementos como par\u00e1metros hayamos definido. Cada elemento del array de par\u00e1metros tendr\u00e1 como clave el par\u00e1metro, y como valor el valor del par\u00e1metro. En el ejemplo, el array $params define los valores de los dos par\u00e1metros definidos en la consulta Cypher. Por \u00faltimo, para ejecutar la consulta con el m\u00e9todo sendCypherQuery() pasaremos la cadena de la consulta seguida del array de par\u00e1metros. Actualizaci\u00f3n y eliminaci\u00f3n Como hemos comentado anteriormente, la interacci\u00f3n con Neo4j usando NeoClient se realiza enviando consultas Cypher al m\u00e9todo sendCypherQuery() , independientemente de si son para crear nodos, para crear relaciones, o si son para actualizar o eliminar datos de la base de datos. Por tanto, para actualizar o eliminar los ejemplos que a\u00f1adimos anteriomente, basta con definir la expresi\u00f3n Cypher adecuada y ejecutarla con el m\u00e9todo sendCypherQuery() . El c\u00f3digo siguiente elimina el path creado en los ejemplos anteriores formado por el actor John Doe , la pel\u00edcula GGVD , y el papel de dicho actor en dicha pel\u00edcula. Consulta b\u00e1sica Los resultados que devuelve una consulta realizada con el m\u00e9todo sendCypherQuery() lo asignaremos a un objeto que posteriormente procesaremos para mostrar el resultado de la consulta. B\u00e1sicamente se trata de hacer lo siguiente: Obtener los resultados mediante el m\u00e9todo getResult() . Aplicaremos este m\u00e9todo en cadena tras sendCypherQuery() . Asignar los resultados de getResult() a un resultset . Recorrer el resultset obteniendo sus elementos (p.e. nodos). El m\u00e9todo getNodes() devuelve los nodos de un resultset Recuperar el valor de una propiedad. El m\u00e9todo getProperty(<property>) aplicado a un nodo devuelve el valor de la propiedad que le pasemos como par\u00e1metro. El ejemplo siguiente muestra los t\u00edtulos de las pel\u00edculas de 1998. Consultas que devuelven un solo nodo En ocasiones nuestras consultas s\u00f3lo devuelven un nodo, o bien s\u00f3lo estamos interesados en recuperar un solo nodo de un resultset . El m\u00e9todo getSingleNode() aplicado a un resultset devuelve un nodo del resultset . Si el resultset conten\u00eda un solo nodo, getSingleNode() nos lo devuelve. El ejemplo siguiente muestra el a\u00f1o de producci\u00f3n de la pel\u00edcula When Harry Met Sally . La consulta recupera un nodo de la base de datos, y mediante getSingleNode() accedemos a \u00e9l. Una vez recuperado ya le podemos aplicar los m\u00e9todos aplicables a nodos, como getProperty(<property>) . \u00bfY si RETURN devuelve varios elementos? Es habitual que las expresiones Cypher incluyan en la cl\u00e1usula RETURN varios elementos (p.e. varios tipos de nodos, relaciones, y dem\u00e1s). Imaginemos la siguiente expresi\u00f3n Cypher: MATCH ( m : Movie { released : 1998 } ) <- [ r : ACTED_IN ] - ( p : Person ) RETURN p , r , m Para este caso, los m\u00e9todos getNodes() y getSingleNode() no funcionar\u00edan correctamente al aplicarlos sobre el resultset , ya que no sabr\u00edan si actuar sobre los nodos p , las relaciones r , o los nodos m . En casos como este, aplicaremos el m\u00e9todo get(<elemento>) sobre el resultset para obtener el elemento del RETURN en el que estemos interesados. El siguiente script ejecuta una consulta que devuelve los nodos pel\u00edcula, persona y relaci\u00f3n ACTED_IN para pel\u00edculas de 1998. A continuaci\u00f3n, asigna los tres elementos del RETURN a tres variables. Para acceder a los elementos que devuelve el RETURN se usa el m\u00e9todo get(<elemento>) sobre el resultset Recorrido del conjunto de nodos En el script anterior, $actors contiene la lista de nodos Person de las pel\u00edculas recuperadas. Para acceder a ellos, basta con iterar sobre $actors con un foreach y acceder a las propiedades de cada nodo con getProperty(<propiedad>) . Recorrido del conjunto de relaciones En el script anterior, $relationships contiene la lista de relaciones entre los nodos de las pel\u00edculas recuperadas y los nodos de los actores que actuan en ellas. Cada relaci\u00f3n tiene dos extremos, el nodo de inicio y el nodo de fin de la relaci\u00f3n. Los m\u00e9todos getStartNode() y getEndNode() aplicados a una relaci\u00f3n devuelven, respectivamente, el nodo de inicio y el nodo de fin de la relaci\u00f3n. Para acceder a los nodos de las relaciones tendremos que iterar sobre $relationships con un foreach , y acceder a los nodos de inicio y fin con getStartNode() y getEndNode() , respectivamente. A continuaci\u00f3n, y ya sobre cada nodo podremos acceder a las propiedades de cada nodo con getProperty(<propiedad>) . Obtener las relaciones de un nodo Si la consulta que hemos realizado, adem\u00e1s de los nodos, contiene los paths o relaciones con los nodos, podemos estar interesados en mostrar las relaciones que llegan o salen de un nodo. Los m\u00e9todos getInboundRelationships() y getOutboundRelationships() devuelven, respectivamente, las relaciones que llegan o salen de un nodo. El m\u00e9todo getRelationships() devuelve todas las relaciones que mantiene un nodo, ya sean de entrada o de salida. El script siguiente muestra un ejemplo en el que a partir de un conjunto de pel\u00edculas ( $movies ), realiza una iteraci\u00f3n con un foreach y para cada pel\u00edcula muestra su t\u00edtulo, obtiene todos las relaciones de entrada con getInboundRelationships() , y finalmente para cada relaci\u00f3n obtiene su nodo de origen (el actor) con getStartNode() , y muestra su nombre con getProperty('name') . Otro ejemplo interesante lo podemos encontrar en el fragmento siguiente. A partir de un conjunto de pel\u00edculas ( $movies ) se realiza una iteraci\u00f3n con un foreach y para cada pel\u00edcula se muestra su t\u00edtulo, y se obtienen todas las relaciones con getRelationships(<relacion>) . Para cada relaci\u00f3n se obtiene su nodo de origen (que podr\u00e1 ser, seg\u00fan la relaci\u00f3n, actor, director, guionista o productor) con getStartNode() , y muestra su nombre con getProperty('name') . Puedes descargar el c\u00f3digo de este tutorial del GitHub de este proyecto.","title":"Neo4j y PHP"},{"location":"Neo4jPHP/#usando-neo4j-y-php","text":"Duraci\u00f3n estimada: 60 minutos Neo4j nos ofrece gran cantidad de clientes para interactuar con \u00e9l mediante diferentes lenguajes de programaci\u00f3n ( Drivers Neo4j ). En nuestro ejemplo interactuaremos con Neo4j mediante PHP. Para PHP existen varios drivers (Neo4jPHP, NeoClient, ...). En la web de Neo4j puedes encontrar una lista m\u00e1s completa de clientes PHP para Neo4j . En este tutorial usaremos NeoClient .","title":"Usando Neo4j y PHP"},{"location":"Neo4jPHP/#instalacion","text":"Como paso previo a la instalaci\u00f3n de NeoClient, necesitas tener instalado Composer , un gestor de dependencias para PHP. En el Tutorial sobre configuraci\u00f3n de un entorno LAMP+NoSQL est\u00e1n disponibles los pasos para tener instalado todo lo necesario para usar Neo4j con PHP (Neo4j, Servidor Apache, PHP y Composer). Siguiendo la Informaci\u00f3n de instalaci\u00f3n de NeoClient hay que crear en la carpeta del proyecto un archivo composer.json en el que se especifica la dependencia con NeoClient. A continuaci\u00f3n, en la carpeta del proyecto instalaremos las dependencias con el comando siguiente composer install","title":"Instalaci\u00f3n"},{"location":"Neo4jPHP/#conexion-a-neo4j","text":"Para usar las clases de NeoClient debemos hacer referencia el espacio de nombres de NeoClient ( Neoxygen\\NeoClient ). Adem\u00e1s, antes de proceder a crear la conexi\u00f3n tenemos que importar el archivo autoload.php generado por Composer al instalar las dependencias. La conexi\u00f3n la crearemos mediante el m\u00e9todo create() de la clase ClientBuilder de NeoClient. En ella indicaremos varios par\u00e1metros, destacando el host y el puerto . En nuestro caso hemos usado localhost y 7474 (el puerto predeterminado de Neo4j). Este c\u00f3digo lo podemos guardar en un archivo (p.e. connection.php ) para que pueda ser utilizado por cualquier script de nuestra aplicaci\u00f3n que tenga que interactuar con Neo4j.","title":"Conexi\u00f3n a Neo4j"},{"location":"Neo4jPHP/#interaccion-con-neo4j","text":"B\u00e1sicamente, la interacci\u00f3n con Neo4j la realizaremos mediante el env\u00edo de consultas Cypher a trav\u00e9s de la conexi\u00f3n que hemos establecido en el paso anterior. El env\u00edo de estas consultas se realiza aplicando a una conexi\u00f3n el m\u00e9todo sendCypherQuery($query, [$params]) . Este m\u00e9todo toma como argumento una consulta Cypher y opcionalmente un array asociativo de par\u00e1metros.","title":"Interacci\u00f3n con Neo4j"},{"location":"Neo4jPHP/#creacion-de-nodos","text":"Los nodos son creados definiendo expresiones en Cypher que ser\u00e1n pasadas como argumento al m\u00e9todo sendCypherQuery() sobre la conexi\u00f3n creada. A continuaci\u00f3n vemos c\u00f3mo crear un nodo Person para un actor con nombre ( name ) John Doe , y un nodo Movie para una pel\u00edcula con t\u00edtulo ( title ) GGVD .","title":"Creaci\u00f3n de nodos"},{"location":"Neo4jPHP/#creacion-de-relaciones","text":"Al igual que los nodos, las relaciones son creadas definiendo expresiones en Cypher que ser\u00e1n pasadas como argumento al m\u00e9todo sendCypherQuery() sobre la conexi\u00f3n creada. A continuaci\u00f3n vemos c\u00f3mo crear una relaci\u00f3n entre los nodos Person y Movie creados anteriormente. La relaci\u00f3n se denomina ACTED_IN y tiene asociada la propiedad roles con el valor ['Johnnie'] indicando que el actor John Doe tiene el papel (rol) de Johnnie en la pel\u00edcula GGVD .","title":"Creaci\u00f3n de relaciones"},{"location":"Neo4jPHP/#uso-de-parametros-en-las-consultas","text":"Las consultas Cypher que pasamos al m\u00e9todo sendCypherQuery() se pueden definir parametrizadas. Los par\u00e1metros se asignar\u00e1n posteriormente antes de enviar la consulta a Neo4j. A continuaci\u00f3n se muestra la misma consulta que usamos anteriormente para definir una relaci\u00f3n ACTED_IN entre un nodo Person y un nodo Movie , pero ahora la crearemos de forma parametrizada. En este caso, el nombre de la persona es pasado como par\u00e1metro ( {theName} ), as\u00ed como el t\u00edtulo de la pel\u00edcula ( {theTitle} ). Para asignar valores a los par\u00e1metros crearemos un array asociativo que tendr\u00e1 tantos elementos como par\u00e1metros hayamos definido. Cada elemento del array de par\u00e1metros tendr\u00e1 como clave el par\u00e1metro, y como valor el valor del par\u00e1metro. En el ejemplo, el array $params define los valores de los dos par\u00e1metros definidos en la consulta Cypher. Por \u00faltimo, para ejecutar la consulta con el m\u00e9todo sendCypherQuery() pasaremos la cadena de la consulta seguida del array de par\u00e1metros.","title":"Uso de par\u00e1metros en las consultas"},{"location":"Neo4jPHP/#actualizacion-y-eliminacion","text":"Como hemos comentado anteriormente, la interacci\u00f3n con Neo4j usando NeoClient se realiza enviando consultas Cypher al m\u00e9todo sendCypherQuery() , independientemente de si son para crear nodos, para crear relaciones, o si son para actualizar o eliminar datos de la base de datos. Por tanto, para actualizar o eliminar los ejemplos que a\u00f1adimos anteriomente, basta con definir la expresi\u00f3n Cypher adecuada y ejecutarla con el m\u00e9todo sendCypherQuery() . El c\u00f3digo siguiente elimina el path creado en los ejemplos anteriores formado por el actor John Doe , la pel\u00edcula GGVD , y el papel de dicho actor en dicha pel\u00edcula.","title":"Actualizaci\u00f3n y eliminaci\u00f3n"},{"location":"Neo4jPHP/#consulta-basica","text":"Los resultados que devuelve una consulta realizada con el m\u00e9todo sendCypherQuery() lo asignaremos a un objeto que posteriormente procesaremos para mostrar el resultado de la consulta. B\u00e1sicamente se trata de hacer lo siguiente: Obtener los resultados mediante el m\u00e9todo getResult() . Aplicaremos este m\u00e9todo en cadena tras sendCypherQuery() . Asignar los resultados de getResult() a un resultset . Recorrer el resultset obteniendo sus elementos (p.e. nodos). El m\u00e9todo getNodes() devuelve los nodos de un resultset Recuperar el valor de una propiedad. El m\u00e9todo getProperty(<property>) aplicado a un nodo devuelve el valor de la propiedad que le pasemos como par\u00e1metro. El ejemplo siguiente muestra los t\u00edtulos de las pel\u00edculas de 1998.","title":"Consulta b\u00e1sica"},{"location":"Neo4jPHP/#consultas-que-devuelven-un-solo-nodo","text":"En ocasiones nuestras consultas s\u00f3lo devuelven un nodo, o bien s\u00f3lo estamos interesados en recuperar un solo nodo de un resultset . El m\u00e9todo getSingleNode() aplicado a un resultset devuelve un nodo del resultset . Si el resultset conten\u00eda un solo nodo, getSingleNode() nos lo devuelve. El ejemplo siguiente muestra el a\u00f1o de producci\u00f3n de la pel\u00edcula When Harry Met Sally . La consulta recupera un nodo de la base de datos, y mediante getSingleNode() accedemos a \u00e9l. Una vez recuperado ya le podemos aplicar los m\u00e9todos aplicables a nodos, como getProperty(<property>) .","title":"Consultas que devuelven un solo nodo"},{"location":"Neo4jPHP/#y-si-return-devuelve-varios-elementos","text":"Es habitual que las expresiones Cypher incluyan en la cl\u00e1usula RETURN varios elementos (p.e. varios tipos de nodos, relaciones, y dem\u00e1s). Imaginemos la siguiente expresi\u00f3n Cypher: MATCH ( m : Movie { released : 1998 } ) <- [ r : ACTED_IN ] - ( p : Person ) RETURN p , r , m Para este caso, los m\u00e9todos getNodes() y getSingleNode() no funcionar\u00edan correctamente al aplicarlos sobre el resultset , ya que no sabr\u00edan si actuar sobre los nodos p , las relaciones r , o los nodos m . En casos como este, aplicaremos el m\u00e9todo get(<elemento>) sobre el resultset para obtener el elemento del RETURN en el que estemos interesados. El siguiente script ejecuta una consulta que devuelve los nodos pel\u00edcula, persona y relaci\u00f3n ACTED_IN para pel\u00edculas de 1998. A continuaci\u00f3n, asigna los tres elementos del RETURN a tres variables. Para acceder a los elementos que devuelve el RETURN se usa el m\u00e9todo get(<elemento>) sobre el resultset","title":"\u00bfY si RETURN devuelve varios elementos?"},{"location":"Neo4jPHP/#recorrido-del-conjunto-de-nodos","text":"En el script anterior, $actors contiene la lista de nodos Person de las pel\u00edculas recuperadas. Para acceder a ellos, basta con iterar sobre $actors con un foreach y acceder a las propiedades de cada nodo con getProperty(<propiedad>) .","title":"Recorrido del conjunto de nodos"},{"location":"Neo4jPHP/#recorrido-del-conjunto-de-relaciones","text":"En el script anterior, $relationships contiene la lista de relaciones entre los nodos de las pel\u00edculas recuperadas y los nodos de los actores que actuan en ellas. Cada relaci\u00f3n tiene dos extremos, el nodo de inicio y el nodo de fin de la relaci\u00f3n. Los m\u00e9todos getStartNode() y getEndNode() aplicados a una relaci\u00f3n devuelven, respectivamente, el nodo de inicio y el nodo de fin de la relaci\u00f3n. Para acceder a los nodos de las relaciones tendremos que iterar sobre $relationships con un foreach , y acceder a los nodos de inicio y fin con getStartNode() y getEndNode() , respectivamente. A continuaci\u00f3n, y ya sobre cada nodo podremos acceder a las propiedades de cada nodo con getProperty(<propiedad>) .","title":"Recorrido del conjunto de relaciones"},{"location":"Neo4jPHP/#obtener-las-relaciones-de-un-nodo","text":"Si la consulta que hemos realizado, adem\u00e1s de los nodos, contiene los paths o relaciones con los nodos, podemos estar interesados en mostrar las relaciones que llegan o salen de un nodo. Los m\u00e9todos getInboundRelationships() y getOutboundRelationships() devuelven, respectivamente, las relaciones que llegan o salen de un nodo. El m\u00e9todo getRelationships() devuelve todas las relaciones que mantiene un nodo, ya sean de entrada o de salida. El script siguiente muestra un ejemplo en el que a partir de un conjunto de pel\u00edculas ( $movies ), realiza una iteraci\u00f3n con un foreach y para cada pel\u00edcula muestra su t\u00edtulo, obtiene todos las relaciones de entrada con getInboundRelationships() , y finalmente para cada relaci\u00f3n obtiene su nodo de origen (el actor) con getStartNode() , y muestra su nombre con getProperty('name') . Otro ejemplo interesante lo podemos encontrar en el fragmento siguiente. A partir de un conjunto de pel\u00edculas ( $movies ) se realiza una iteraci\u00f3n con un foreach y para cada pel\u00edcula se muestra su t\u00edtulo, y se obtienen todas las relaciones con getRelationships(<relacion>) . Para cada relaci\u00f3n se obtiene su nodo de origen (que podr\u00e1 ser, seg\u00fan la relaci\u00f3n, actor, director, guionista o productor) con getStartNode() , y muestra su nombre con getProperty('name') . Puedes descargar el c\u00f3digo de este tutorial del GitHub de este proyecto.","title":"Obtener las relaciones de un nodo"},{"location":"Usando MongoDB y PHP/","text":"Usando MongoDB y PHP Duraci\u00f3n estimada: 60 minutos MongoDB nos ofrece gran cantidad de clientes para interactuar con \u00e9l mediante gran cantidad de lenguajes de programaci\u00f3n ( Drivers MongoDB ). En nuestro ejemplo interactuaremos con MongoDB mediante la Librer\u00eda PHP para MongoDB. Instalaci\u00f3n Siguiendo la Informaci\u00f3n de instalaci\u00f3n de la Librer\u00eda PHP para MongoDB podr\u00e1s instalar estos dos componentes necesarios: La extensi\u00f3n mongodb para PHP en tu equipo a trav\u00e9s del repositorio de extensiones PHP PECL . La Librer\u00eda PHP en s\u00ed para MongoDB Aqu\u00ed mostraremos los pasos de instalaci\u00f3n en un Ubuntu Linux que ya tiene instalado previamente MongoDB y un entorno LAMP ( Tutorial sobre configuraci\u00f3n de un entorno LAMP+NoSQL ). B\u00e1sicamente se trata de descargar e instalar el driver, a\u00f1adir la extensi\u00f3n al php.ini , y reiniciar el servidor Apache. Para descargar e instalar el driver lo haremos con sudo pecl install mongodb Esto har\u00e1 que se descargue el driver, se compile y se instale en nuestro sistema como una extensi\u00f3n. Si estuvi\u00e9semos utilizando XAMPP, tendr\u00edamos que utilzar el pecl de XAMPP. Por ejemplo, podr\u00edamos hacerlo de una forma similiar a esta: sudo / Applications / XAMPP / xamppfiles / bin / pecl install mongodb Si no tienes instalado PEAR y el paquete php-dev deber\u00e1s instalarlos con sudo apt-get install -y php-pear sudo apt-get install -y php-dev A continuaci\u00f3n hay que modificar el archivo php.ini para indicar que cargue la extensi\u00f3n de MongoDB ( mongodb.so ). php.ini se encuentra en /etc/php/7.0/apache2/php.ini . Tendr\u00e1s que a\u00f1adir lo siguiente en la zona de extensiones. extension = mongodb . so Ahora, reiniciaremos el servidor Apache para que tengan efecto los cambios sudo service apache2 restart Manos a la obra En este Tutorial sencillo de PHP con MongoDB puedes encontrar un ejemplo guiado de c\u00f3mo comenzar con los aspectos b\u00e1sicos del scripting PHP con MongoDB. Adem\u00e1s, es muy conveniente tener a mano esta [Referencia] (https://docs.mongodb.com/php-library/master/reference/) en la que podr\u00e1s encontrar casi todo lo que necesitas para tu aplicaci\u00f3n PHP con MongoDB. Instalaci\u00f3n de la librer\u00eda La Librer\u00eda PHP para MongoDB ofrece una abstracci\u00f3n de alto nivel sobre el driver PHP para MongoDB . Instalaremos la Librer\u00eda PHP para MongoDB mediante Composer ejecutando el comando siguiente sobre la ra\u00edz de nuestro proyecto composer require mongodb / mongodb Esto instalar\u00e1 la librer\u00eda en nuestro proyecto y generar\u00e1 los archivos de autoload . Para usar la librer\u00eda en el proyecto comenzaremos con el script siguiente <?php require 'vendor/autoload.php' ; ?> Conexi\u00f3n a MongoDB Una vez instalada la librer\u00eda, el proceso de conexi\u00f3n es muy sencillo. Basta con instanciar la clase MongoDB\\Client . Si no indicamos par\u00e1metros se conectar\u00e1 usando localhost y el puerto predeterminado ( 27017 ). Esta clase sirve como punto de entrada a la MongoDB PHP Library. Usaremos la clase \\MongoDB\\Client para conectarnos a un servidor o cluster de servidores MongoDB y act\u00faa como gateway para acceder a bases de datos o colecciones. Selecci\u00f3n de la colecci\u00f3n La conexi\u00f3n creada nos servir\u00e1 para seleccionar la base de datos y la colecci\u00f3n con la que queremos trabajar. Podremos crear un objeto para la base de datos y otro para la colecci\u00f3n, o bien crear s\u00f3lo el objeto de la colecci\u00f3n si no queremos usar ninguno de los m\u00e9todos aplicables a la base de datos (crear bases de datos, operaciones con el profile , write concern , ...) A continuaci\u00f3n vemos c\u00f3mo crear un objeto para una base de datos de ejemplo denominada ggvdTest y un objeto para una colecci\u00f3n de prueba denominada actor , que incluir\u00e1 actores. Inserci\u00f3n de documentos Los documentos se crean mediante arrays asociativos. Estos documentos se insertar\u00e1n con los m\u00e9todos insertOne() o insertMany() sobre la colecci\u00f3n correspondiente, para insertar uno o varios documentos, respectivamente. Informaci\u00f3n A los m\u00e9todos de inserci\u00f3n, actualizaci\u00f3n y eliminaci\u00f3n le podremos pasar opcionalmente un array de opciones (p.e. para especificar el Write Concern ). Actualizaci\u00f3n de documentos Los documentos se actualizan mediante los m\u00e9todos updateOne() o updateMany() sobre una colecci\u00f3n. A los m\u00e9todos le pasaremos el array asociativo con los criterios, el nuevo objeto (que podr\u00e1 incluir operadores de actualizaci\u00f3n para modificar o reemplazar documentos), y de forma optativa las opciones de actualizaci\u00f3n. Entre las opciones de actualizaci\u00f3n m\u00e1s destacadas se encuentran upsert ( boolean ), que especifica si crear un documento nuevo o no si no hay ninguna coincidencia en la b\u00fasqueda, y writeConcern . En el caso de que usemos el m\u00e9todo updateOne() y existan varios documentos que cumplan los criterios, s\u00f3lo se actualizar\u00e1 el primer documento que cumpla los criterios. Eliminaci\u00f3n de documentos La eliminaci\u00f3n de documentos se realiza mediante los m\u00e9todos deleteOne() o deleteMany() aplicados a una colecci\u00f3n. A los m\u00e9todos le pasaremos el array asociativo con los criterios, y de forma optativa las opciones de eliminaci\u00f3n. Al igual que con el m\u00e9todo updateOne() , en el caso de que usemos el m\u00e9todo deleteOne() y existan varios documentos a que cumplan los criterios, s\u00f3lo se eliminar\u00e1 el primer documento que cumpla los criterios. B\u00fasqueda de documentos La b\u00fasqueda de documentos se realiza b\u00e1sicamente mediante los m\u00e9todos findOne() y find() aplicados a una colecci\u00f3n para buscar, respectivamente, uno o varios documentos que cumplan los criterios de b\u00fasqueda. En el caso de usar find() , recorreremos el resultado con un bucle foreach y en cada pasada cada documento ser\u00e1 tratado como un array asociativo. Framework de agregaci\u00f3n Las operaciones relacionadas con el framework de agregaci\u00f3n se realizan con el m\u00e9todo aggregate() . A este m\u00e9todo le proporcionaremos el pipeline de operaciones ( $match , $project , $group , $sort , ...) en forma de array asociativo. El m\u00e9todo devolver\u00e1 el resultado en forma de array tal y como ocurre como cuando se usa el framework de agregaci\u00f3n desde la shell. Puedes descargar el c\u00f3digo de este tutorial del GitHub de este proyecto.","title":"MongoDB y PHP"},{"location":"Usando MongoDB y PHP/#usando-mongodb-y-php","text":"Duraci\u00f3n estimada: 60 minutos MongoDB nos ofrece gran cantidad de clientes para interactuar con \u00e9l mediante gran cantidad de lenguajes de programaci\u00f3n ( Drivers MongoDB ). En nuestro ejemplo interactuaremos con MongoDB mediante la Librer\u00eda PHP para MongoDB.","title":"Usando MongoDB y PHP"},{"location":"Usando MongoDB y PHP/#instalacion","text":"Siguiendo la Informaci\u00f3n de instalaci\u00f3n de la Librer\u00eda PHP para MongoDB podr\u00e1s instalar estos dos componentes necesarios: La extensi\u00f3n mongodb para PHP en tu equipo a trav\u00e9s del repositorio de extensiones PHP PECL . La Librer\u00eda PHP en s\u00ed para MongoDB Aqu\u00ed mostraremos los pasos de instalaci\u00f3n en un Ubuntu Linux que ya tiene instalado previamente MongoDB y un entorno LAMP ( Tutorial sobre configuraci\u00f3n de un entorno LAMP+NoSQL ). B\u00e1sicamente se trata de descargar e instalar el driver, a\u00f1adir la extensi\u00f3n al php.ini , y reiniciar el servidor Apache. Para descargar e instalar el driver lo haremos con sudo pecl install mongodb Esto har\u00e1 que se descargue el driver, se compile y se instale en nuestro sistema como una extensi\u00f3n. Si estuvi\u00e9semos utilizando XAMPP, tendr\u00edamos que utilzar el pecl de XAMPP. Por ejemplo, podr\u00edamos hacerlo de una forma similiar a esta: sudo / Applications / XAMPP / xamppfiles / bin / pecl install mongodb Si no tienes instalado PEAR y el paquete php-dev deber\u00e1s instalarlos con sudo apt-get install -y php-pear sudo apt-get install -y php-dev A continuaci\u00f3n hay que modificar el archivo php.ini para indicar que cargue la extensi\u00f3n de MongoDB ( mongodb.so ). php.ini se encuentra en /etc/php/7.0/apache2/php.ini . Tendr\u00e1s que a\u00f1adir lo siguiente en la zona de extensiones. extension = mongodb . so Ahora, reiniciaremos el servidor Apache para que tengan efecto los cambios sudo service apache2 restart","title":"Instalaci\u00f3n"},{"location":"Usando MongoDB y PHP/#manos-a-la-obra","text":"En este Tutorial sencillo de PHP con MongoDB puedes encontrar un ejemplo guiado de c\u00f3mo comenzar con los aspectos b\u00e1sicos del scripting PHP con MongoDB. Adem\u00e1s, es muy conveniente tener a mano esta [Referencia] (https://docs.mongodb.com/php-library/master/reference/) en la que podr\u00e1s encontrar casi todo lo que necesitas para tu aplicaci\u00f3n PHP con MongoDB.","title":"Manos a la obra"},{"location":"Usando MongoDB y PHP/#instalacion-de-la-libreria","text":"La Librer\u00eda PHP para MongoDB ofrece una abstracci\u00f3n de alto nivel sobre el driver PHP para MongoDB . Instalaremos la Librer\u00eda PHP para MongoDB mediante Composer ejecutando el comando siguiente sobre la ra\u00edz de nuestro proyecto composer require mongodb / mongodb Esto instalar\u00e1 la librer\u00eda en nuestro proyecto y generar\u00e1 los archivos de autoload . Para usar la librer\u00eda en el proyecto comenzaremos con el script siguiente <?php require 'vendor/autoload.php' ; ?>","title":"Instalaci\u00f3n de la librer\u00eda"},{"location":"Usando MongoDB y PHP/#conexion-a-mongodb","text":"Una vez instalada la librer\u00eda, el proceso de conexi\u00f3n es muy sencillo. Basta con instanciar la clase MongoDB\\Client . Si no indicamos par\u00e1metros se conectar\u00e1 usando localhost y el puerto predeterminado ( 27017 ). Esta clase sirve como punto de entrada a la MongoDB PHP Library. Usaremos la clase \\MongoDB\\Client para conectarnos a un servidor o cluster de servidores MongoDB y act\u00faa como gateway para acceder a bases de datos o colecciones.","title":"Conexi\u00f3n a MongoDB"},{"location":"Usando MongoDB y PHP/#seleccion-de-la-coleccion","text":"La conexi\u00f3n creada nos servir\u00e1 para seleccionar la base de datos y la colecci\u00f3n con la que queremos trabajar. Podremos crear un objeto para la base de datos y otro para la colecci\u00f3n, o bien crear s\u00f3lo el objeto de la colecci\u00f3n si no queremos usar ninguno de los m\u00e9todos aplicables a la base de datos (crear bases de datos, operaciones con el profile , write concern , ...) A continuaci\u00f3n vemos c\u00f3mo crear un objeto para una base de datos de ejemplo denominada ggvdTest y un objeto para una colecci\u00f3n de prueba denominada actor , que incluir\u00e1 actores.","title":"Selecci\u00f3n de la colecci\u00f3n"},{"location":"Usando MongoDB y PHP/#insercion-de-documentos","text":"Los documentos se crean mediante arrays asociativos. Estos documentos se insertar\u00e1n con los m\u00e9todos insertOne() o insertMany() sobre la colecci\u00f3n correspondiente, para insertar uno o varios documentos, respectivamente. Informaci\u00f3n A los m\u00e9todos de inserci\u00f3n, actualizaci\u00f3n y eliminaci\u00f3n le podremos pasar opcionalmente un array de opciones (p.e. para especificar el Write Concern ).","title":"Inserci\u00f3n de documentos"},{"location":"Usando MongoDB y PHP/#actualizacion-de-documentos","text":"Los documentos se actualizan mediante los m\u00e9todos updateOne() o updateMany() sobre una colecci\u00f3n. A los m\u00e9todos le pasaremos el array asociativo con los criterios, el nuevo objeto (que podr\u00e1 incluir operadores de actualizaci\u00f3n para modificar o reemplazar documentos), y de forma optativa las opciones de actualizaci\u00f3n. Entre las opciones de actualizaci\u00f3n m\u00e1s destacadas se encuentran upsert ( boolean ), que especifica si crear un documento nuevo o no si no hay ninguna coincidencia en la b\u00fasqueda, y writeConcern . En el caso de que usemos el m\u00e9todo updateOne() y existan varios documentos que cumplan los criterios, s\u00f3lo se actualizar\u00e1 el primer documento que cumpla los criterios.","title":"Actualizaci\u00f3n de documentos"},{"location":"Usando MongoDB y PHP/#eliminacion-de-documentos","text":"La eliminaci\u00f3n de documentos se realiza mediante los m\u00e9todos deleteOne() o deleteMany() aplicados a una colecci\u00f3n. A los m\u00e9todos le pasaremos el array asociativo con los criterios, y de forma optativa las opciones de eliminaci\u00f3n. Al igual que con el m\u00e9todo updateOne() , en el caso de que usemos el m\u00e9todo deleteOne() y existan varios documentos a que cumplan los criterios, s\u00f3lo se eliminar\u00e1 el primer documento que cumpla los criterios.","title":"Eliminaci\u00f3n de documentos"},{"location":"Usando MongoDB y PHP/#busqueda-de-documentos","text":"La b\u00fasqueda de documentos se realiza b\u00e1sicamente mediante los m\u00e9todos findOne() y find() aplicados a una colecci\u00f3n para buscar, respectivamente, uno o varios documentos que cumplan los criterios de b\u00fasqueda. En el caso de usar find() , recorreremos el resultado con un bucle foreach y en cada pasada cada documento ser\u00e1 tratado como un array asociativo.","title":"B\u00fasqueda de documentos"},{"location":"Usando MongoDB y PHP/#framework-de-agregacion","text":"Las operaciones relacionadas con el framework de agregaci\u00f3n se realizan con el m\u00e9todo aggregate() . A este m\u00e9todo le proporcionaremos el pipeline de operaciones ( $match , $project , $group , $sort , ...) en forma de array asociativo. El m\u00e9todo devolver\u00e1 el resultado en forma de array tal y como ocurre como cuando se usa el framework de agregaci\u00f3n desde la shell. Puedes descargar el c\u00f3digo de este tutorial del GitHub de este proyecto.","title":"Framework de agregaci\u00f3n"},{"location":"about/","text":"About Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Primer apartado Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Segundo apartado Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. :memo: Memo Admonition use blockquotes with emoji indicators for admonition memos, callout etc.. Informaci\u00f3n Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Cite Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.","title":"About"},{"location":"about/#about","text":"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.","title":"About"},{"location":"about/#primer-apartado","text":"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.","title":"Primer apartado"},{"location":"about/#segundo-apartado","text":"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. :memo: Memo Admonition use blockquotes with emoji indicators for admonition memos, callout etc.. Informaci\u00f3n Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Cite Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.","title":"Segundo apartado"},{"location":"index2/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs . yml # The configuration file . docs / index . md # The documentation homepage . ... # Other markdown pages , images and other files .","title":"Welcome to MkDocs"},{"location":"index2/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"index2/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"index2/#project-layout","text":"mkdocs . yml # The configuration file . docs / index . md # The documentation homepage . ... # Other markdown pages , images and other files .","title":"Project layout"}]}